# lab_4_3 - 带校验的串行数据生成器

## 项目概述

本实验设计了一个带校验功能的串行数据生成器，用于产生包含帧头、数据和校验和的完整数据帧。系统循环生成特定的帧头序列（"11101000"），然后输出 40 位数据（包括 4 个 8 位数据和 1 个 8 位校验和），可用于测试串行数据接收系统。

## 系统架构

本工程包含一个主要模块：

**seq_generator**：串行数据生成模块，用于循环生成包含帧头、数据和校验和的完整数据帧

## Verilog程序设计

### 串行数据生成模块（seq_generator.v）

#### 模块功能

`seq_generator` 模块实现了一个循环的串行数据生成器，具有以下特性：

- **帧头生成**：生成特定的 8 位序列 "11101000" 作为数据帧的起始标志
- **数据输出**：输出 4 个 8 位数据字节（DATA0~DATA3）
- **校验和生成**：输出 8 位校验和（4 个数据字节的和）
- **循环传输**：完成一帧数据（48 位）后自动重新开始
- **异步复位**：低电平异步复位功能，优先级最高
- **串行输出**：按位输出数据，每个时钟周期输出 1 位

#### 端口说明

| 端口  | 方向   | 位宽 | 说明                       |
| ----- | ------ | ---- | -------------------------- |
| clk   | input  | 1    | 系统时钟                   |
| rst_n | input  | 1    | 异步复位信号（低电平有效） |
| data  | output | 1    | 串行数据输出               |

#### 参数定义

模块定义了以下常量参数，用于指定输出的数据内容：

```verilog
parameter HEAD  = 8'b11101000;  // 帧头序列
parameter DATA0 = 8'b11110000;  // 第一个数据字节 (0xF0)
parameter DATA1 = 8'b00001111;  // 第二个数据字节 (0x0F)
parameter DATA2 = 8'b11111111;  // 第三个数据字节 (0xFF)
parameter DATA3 = 8'b10101010;  // 第四个数据字节 (0xAA)
parameter SUM   = 8'b10101000;  // 校验和 (0xA8 = 0xF0+0x0F+0xFF+0xAA的低8位)
```

#### 功能实现机制

##### 1. 位计数器

使用 6 位计数器 `bit_cnt` 记录当前输出的位位置（0~47，共 48 位）：

- **计数范围**：0~47（6 个字节 × 8 位/字节）
- **循环计数**：计数到 47 后自动归零，实现循环发送
- **复位行为**：异步复位时清零

```verilog
always @ (posedge clk or negedge rst_n)
begin 
    if(!rst_n)
        bit_cnt <= 1'b0;
    else if(bit_cnt < 6'd47)
        bit_cnt <= bit_cnt + 1'b1;
    else
        bit_cnt <= 1'b0;
end
```

##### 2. 数据输出逻辑

根据位计数器的高 3 位 `bit_cnt[5:3]` 选择当前输出的字节，根据低 3 位 `bit_cnt[2:0]` 选择字节内的具体位：

- **字节选择**：通过 `case` 语句根据 `bit_cnt[5:3]` 确定输出哪个字节
- **位选择**：使用 `7-bit_cnt[2:0]` 实现从高位到低位的顺序输出
- **输出顺序**：先输出帧头，依次输出 DATA0~DATA3，最后输出校验和

```verilog
always @ (posedge clk or negedge rst_n)
begin 
    if(!rst_n)
        data <= 1'b0;
    else
        case(bit_cnt[5:3])
            3'b000 : data <= HEAD[3'd7-bit_cnt[2:0]];   // 位 0-7: 帧头
            3'b001 : data <= DATA0[3'd7-bit_cnt[2:0]];  // 位 8-15: DATA0
            3'b010 : data <= DATA1[3'd7-bit_cnt[2:0]];  // 位 16-23: DATA1
            3'b011 : data <= DATA2[3'd7-bit_cnt[2:0]];  // 位 24-31: DATA2
            3'b100 : data <= DATA3[3'd7-bit_cnt[2:0]];  // 位 32-39: DATA3
            3'b101 : data <= SUM[3'd7-bit_cnt[2:0]];    // 位 40-47: 校验和
        endcase
end
```

#### 数据帧结构

完整的数据帧包含 48 位，结构如下：

| 位范围 | 字节名称 | 内容     | 十六进制值 |
| ------ | -------- | -------- | ---------- |
| 0-7    | HEAD     | 11101000 | 0xE8       |
| 8-15   | DATA0    | 11110000 | 0xF0       |
| 16-23  | DATA1    | 00001111 | 0x0F       |
| 24-31  | DATA2    | 11111111 | 0xFF       |
| 32-39  | DATA3    | 10101010 | 0xAA       |
| 40-47  | SUM      | 10101000 | 0xA8       |

**校验和计算**：SUM = (DATA0 + DATA1 + DATA2 + DATA3) & 0xFF = (0xF0 + 0x0F + 0xFF + 0xAA) & 0xFF = 0x2A8 & 0xFF = 0xA8

## ModelSim(Verilog TB代码仿真)

本工程使用 ModelSim 进行功能仿真，验证串行数据生成器的正确性。

### 仿真环境配置

- **时间单位**：根据项目设置配置
- **时钟频率**：可配置的时钟频率
- **仿真时长**：建议至少观察 2-3 个完整数据帧的输出（每帧 48 个时钟周期）

### 测试激励建议

1. **时钟生成**：产生连续的时钟信号
2. **复位序列**：
   - 初始时刻 rst_n=0，复位系统
   - 适当延时后释放复位（rst_n=1）
3. **观察输出**：监测 `data` 信号的串行输出

### 观察信号

在 ModelSim 中应观察以下关键信号：

1. **clk**：系统时钟信号
2. **rst_n**：复位信号
3. **bit_cnt**：位计数器，显示当前输出位的位置（0~47）
4. **data**：串行数据输出，应按照帧头→DATA0→DATA1→DATA2→DATA3→SUM 的顺序输出

### 预期结果

在正常工作状态下：

1. **复位阶段**：

   - `rst_n=0` 时，`bit_cnt` 清零，`data` 输出为 0
   - 释放复位后，系统开始正常工作
2. **数据输出阶段**：

   - **位 0-7**（bit_cnt=0~7）：输出帧头 "11101000"
   - **位 8-15**（bit_cnt=8~15）：输出 DATA0 "11110000"
   - **位 16-23**（bit_cnt=16~23）：输出 DATA1 "00001111"
   - **位 24-31**（bit_cnt=24~31）：输出 DATA2 "11111111"
   - **位 32-39**（bit_cnt=32~39）：输出 DATA3 "10101010"
   - **位 40-47**（bit_cnt=40~47）：输出 SUM "10101000"
3. **循环工作**：

   - 完成 48 位输出后，`bit_cnt` 自动归零
   - 系统重新开始输出下一帧数据
   - 每帧数据内容完全相同，实现循环发送
4. **输出验证**：

   - 可以使用波形查看器或将 `data` 信号按 8 位分组查看
   - 验证校验和：DATA0 + DATA1 + DATA2 + DATA3 = 0xF0 + 0x0F + 0xFF + 0xAA = 0x2A8，取低 8 位为 0xA8

## FPGA板子硬件实验

本工程不涉及。

2025/10/29

ChrisChan
