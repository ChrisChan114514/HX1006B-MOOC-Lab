# lab_4_1 - 序列检测器

## 项目概述

本实验设计了一个基于有限状态机（FSM）的序列检测器，用于检测串行数据流中的特定序列 "11101000"。当检测到完整序列时，输出信号 `sout` 置高，支持异步复位功能。

## Verilog程序设计

### 模块功能

`seq_detect` 模块实现了一个序列检测器，具有以下特性：

- **序列检测**：检测特定的 8 位序列 "11101000"
- **状态机设计**：采用 Moore 型有限状态机，共 9 个状态（s0~s8）
- **异步复位**：低电平异步复位功能，优先级最高
- **实时检测**：逐位检测串行输入数据，匹配序列时立即输出
- **容错设计**：检测失败时自动返回相应状态，支持重叠序列检测

### 功能实现机制

#### 状态机设计

模块采用三段式状态机设计，包含 9 个状态：

- **s0**：初始状态，等待第一个 '1'
- **s1**：检测到第一个 '1'
- **s2**：检测到连续两个 '1'（"11"）
- **s3**：检测到连续三个 '1'（"111"）
- **s4**：检测到 "1110"
- **s5**：检测到 "11101"
- **s6**：检测到 "111010"
- **s7**：检测到 "1110100"
- **s8**：检测到完整序列 "11101000"（输出状态）

#### 状态转移逻辑

根据当前状态和输入 `data_in`，状态机按照以下规则转移：

- **s0→s1**：输入为 '1' 时，开始检测序列
- **s1→s2**：继续输入 '1'
- **s2→s3**：继续输入 '1'
- **s3→s4**：输入为 '0'，前三位匹配成功
- **s4→s5**：输入为 '1'
- **s5→s6**：输入为 '0'
- **s6→s7**：输入为 '0'
- **s7→s8**：输入为 '0'，完整序列匹配成功
- **容错处理**：在任何状态下如果输入不匹配，根据已输入的位返回合适的状态

#### 输出逻辑

- **sout 输出**：仅当状态机处于 s8 状态时，`sout` 输出为高电平
- **Moore 型**：输出仅取决于当前状态，与输入无关

### 端口说明

| 端口    | 方向   | 位宽 | 说明                       |
| ------- | ------ | ---- | -------------------------- |
| clk     | input  | 1    | 系统时钟                   |
| rst_n   | input  | 1    | 异步复位信号（低电平有效） |
| data_in | input  | 1    | 串行数据输入               |
| sout    | output | 1    | 序列检测输出（高电平有效） |

## ModelSim(Verilog TB代码仿真)

本工程包含完整的仿真测试平台 `seq_detect_tb.v`，用于验证序列检测器的功能。

### 仿真环境配置

- **时间单位**：`timescale 10ns/100ps`（时间刻度 10ns，时间精度 100ps）
- **时钟频率**：100MHz（周期 10ns，仿真中为 1 个时间单位）
- **仿真时长**：约 40 个时钟周期

### 测试激励

1. **时钟生成**：产生周期为 10ns 的连续时钟信号（100MHz）
2. **复位序列**：
   - 初始时刻 rst_n=0，复位系统
   - 100ns 后释放复位（rst_n=1）
3. **测试数据序列**：
   - 前 10 个周期：输入随机数据
   - 接下来 9 个周期：输入目标序列 "11101000"
     - 第 1 个周期：data_in = 1
     - 第 2 个周期：data_in = 1
     - 第 3 个周期：data_in = 1
     - 第 4 个周期：data_in = 1（多余的1，用于测试容错）
     - 第 5 个周期：data_in = 0
     - 第 6 个周期：data_in = 1
     - 第 7 个周期：data_in = 0
     - 第 8 个周期：data_in = 0
     - 第 9 个周期：data_in = 0
   - 最后 10 个周期：输入随机数据
4. **运行测试**：仿真完成后自动停止

### 观察信号

- **current_state**：观察状态机状态转移过程（s0→s1→...→s8）
- **data_in**：输入数据流
- **sout**：当检测到完整序列 "11101000" 后，sout 应在对应的时钟周期变为高电平

### 预期结果

当输入完整序列 "11101000" 时：

- 状态机依次经过 s0→s1→s2→s3→s4→s5→s6→s7→s8
- 在 s8 状态时，`sout` 输出高电平
- 如果序列中断或不匹配，状态机返回相应的初始状态

## FPGA板子硬件实验

生成 `.sof` 配置文件，下载到 FPGA 开发板进行硬件验证。

### 引脚分配

本工程的引脚分配如下：

#### 输入信号

| 信号    | FPGA引脚 | 硬件元件 | 说明                         |
| ------- | -------- | -------- | ---------------------------- |
| clk     | F3       | KEY2     | 时钟输入（按下为低电平）     |
| rst_n   | M1       | KEY1     | 复位信号（按下为低电平）     |
| data_in | E16      | SW       | 串行数据输入（上拨为高电平） |

#### 输出信号

| 信号 | FPGA引脚 | 硬件元件 | 说明                            |
| ---- | -------- | -------- | ------------------------------- |
| sout | T10      | LED1     | 序列检测输出（高电平点亮 LED1） |

### 硬件测试步骤

1. **编译下载**

   - 在 Quartus II 中编译工程，生成 `.sof` 文件
   - 使用 USB Blaster 或其他下载器将配置文件下载到 FPGA
2. **复位测试**

   - 按下 KEY1（rst_n=0）复位系统
   - LED1 应熄灭（sout=0）
   - 松开 KEY1（rst_n=1），系统开始正常工作
3. **序列输入测试**

   本设计采用手动按键作为时钟输入，通过拨动开关输入数据序列：

   - **时钟输入**：每按一次 KEY2（下降沿触发），系统读取一次 data_in 的值
   - **数据输入**：通过 SW 开关控制 data_in 的电平

     - SW 上拨：data_in = 1（高电平）
     - SW 下拨：data_in = 0（低电平）
   - **输入目标序列 "11101000"**：

     1. SW 上拨（设置 data_in=1），按一次 KEY2 → 输入第1个 '1'
     2. SW 保持上拨，按一次 KEY2 → 输入第2个 '1'
     3. SW 保持上拨，按一次 KEY2 → 输入第3个 '1'
     4. SW 下拨（设置 data_in=0），按一次 KEY2 → 输入第4个 '0'
     5. SW 上拨（设置 data_in=1），按一次 KEY2 → 输入第5个 '1'
     6. SW 下拨（设置 data_in=0），按一次 KEY2 → 输入第6个 '0'
     7. SW 保持下拨，按一次 KEY2 → 输入第7个 '0'
     8. SW 保持下拨，按一次 KEY2 → 输入第8个 '0'
4. **观察输出**

   - 当完整序列 "11101000" 输入完成后，LED1 应点亮（sout=1）
   - 表示序列检测成功
   - 如果输入序列不正确，LED1 保持熄灭状态
   - 可以通过按下 KEY1 复位后重新测试
   - 任何时候都可以按下 KEY1 进行复位，重新开始序列检测
