# lab_4_2 - 带校验的串行数据接收器

## 项目概述

本实验设计了一个带校验功能的串行数据接收器，结合了帧头检测和数据校验两大功能。系统通过检测特定的帧头序列（"11101000"）来识别数据帧的开始，然后接收 40 位数据（包括 4 个 8 位数据和 1 个 8 位校验和），并验证数据的完整性。

## 系统架构

本工程包含两个主要模块：

1. **seq_detect**：序列检测模块，用于检测帧头序列 "11101000"
2. **seq_rd**：串行数据接收模块，协调帧头检测、数据接收和校验功能

## Verilog程序设计

### 1. 序列检测模块（seq_detect.v）

#### 模块功能

`seq_detect` 模块实现了基于有限状态机（FSM）的帧头检测器，具有以下特性：

- **帧头检测**：检测特定的 8 位序列 "11101000" 作为数据帧的起始标志
- **状态机设计**：采用 Moore 型有限状态机，共 9 个状态（s0~s8）
- **异步复位**：低电平异步复位功能，优先级最高
- **实时检测**：逐位检测串行输入数据，匹配序列时立即输出
- **容错设计**：检测失败时自动返回相应状态，支持重叠序列检测

#### 端口说明

| 端口    | 方向   | 位宽 | 说明                       |
| ------- | ------ | ---- | -------------------------- |
| clk     | input  | 1    | 系统时钟                   |
| rst_n   | input  | 1    | 异步复位信号（低电平有效） |
| data_in | input  | 1    | 串行数据输入               |
| sout    | output | 1    | 帧头检测输出（高电平有效） |

#### 状态机设计

模块采用三段式状态机设计，包含 9 个状态：

- **s0**：初始状态，等待第一个 '1'
- **s1**：检测到第一个 '1'
- **s2**：检测到连续两个 '1'（"11"）
- **s3**：检测到连续三个 '1'（"111"）
- **s4**：检测到 "1110"
- **s5**：检测到 "11101"
- **s6**：检测到 "111010"
- **s7**：检测到 "1110100"
- **s8**：检测到完整帧头 "11101000"（输出状态）

#### 状态转移逻辑

根据当前状态和输入 `data_in`，状态机按照以下规则转移：

- **s0→s1**：输入为 '1' 时，开始检测序列
- **s1→s2**：继续输入 '1'
- **s2→s3**：继续输入 '1'
- **s3→s4**：输入为 '0'，前三位匹配成功
- **s4→s5**：输入为 '1'
- **s5→s6**：输入为 '0'
- **s6→s7**：输入为 '0'
- **s7→s8**：输入为 '0'，完整序列匹配成功
- **容错处理**：在任何状态下如果输入不匹配，根据已输入的位返回合适的状态

### 2. 串行数据接收模块（seq_rd.v）

#### 模块功能

`seq_rd` 模块是顶层模块，负责协调整个数据接收和校验过程：

- **帧头检测**：调用 `seq_detect` 模块检测帧头序列 "11101000"
- **数据接收**：检测到帧头后，接收 40 位串行数据
- **数据解析**：将 40 位数据解析为 4 个 8 位数据字节和 1 个 8 位校验和
- **求和校验**：对接收到的 4 个数据字节进行求和校验
- **校验标志输出**：当接收完 40 位数据且校验和匹配时，输出校验成功标志

#### 端口说明

| 端口           | 方向   | 位宽 | 说明                       |
| -------------- | ------ | ---- | -------------------------- |
| clk            | input  | 1    | 系统时钟                   |
| rst_n          | input  | 1    | 异步复位信号（低电平有效） |
| data_in        | input  | 1    | 串行数据输入               |
| out_data0      | output | 8    | 第一个数据字节             |
| out_data1      | output | 8    | 第二个数据字节             |
| out_data2      | output | 8    | 第三个数据字节             |
| out_data3      | output | 8    | 第四个数据字节             |
| out_check_flag | output | 1    | 校验成功标志（高电平有效） |

#### 功能实现机制

##### 1. 帧头检测

使用 `seq_detect` 模块实例化，实时监测串行数据流中的帧头序列 "11101000"。当检测到帧头时，`head_check` 信号置高，触发数据接收过程。

```verilog
seq_detect u_seq_detect(
    .clk      (clk),
    .rst_n    (rst_n),
    .data_in  (data_in),
    .sout     (head_check)
);
```

##### 2. 数据接收

- **位计数器**：`bit_cnt` 用于记录接收到的数据位数（0~40）
- **数据移位**：使用 41 位移位寄存器 `data` 存储接收的串行数据
- **接收流程**：
  - 检测到帧头后，开始计数并接收数据
  - 每个时钟周期接收 1 位数据，数据右移存储
  - 接收满 40 位后停止计数

```verilog
always @ (posedge clk or negedge rst_n) begin 
    if(!rst_n) begin 
        bit_cnt <= 6'b0;
        data <= 40'b0;
    end
    else if(head_check) begin
        bit_cnt <= 6'd1;
        data[0] <= data_in;
    end
    else if(bit_cnt < 6'd40) begin
        bit_cnt <= bit_cnt + 1'b1;
        data[0] <= data_in;
        data[40:1] <= data[39:0];
    end
    else begin
        bit_cnt <= 6'b0;
    end
end
```

##### 3. 数据解析

接收到的 40 位数据按照以下格式解析：

- **out_data0 [7:0]**：第 1~8 位数据（第一个字节）
- **out_data1 [7:0]**：第 9~16 位数据（第二个字节）
- **out_data2 [7:0]**：第 17~24 位数据（第三个字节）
- **out_data3 [7:0]**：第 25~32 位数据（第四个字节）
- **sum_check [7:0]**：第 33~40 位数据（校验和字节）

```verilog
assign {out_data0, out_data1, out_data2, out_data3, sum_check} = data[39:0];
```

##### 4. 求和校验

- **累加计算**：每接收完一个完整的 8 位数据（bit_cnt[2:0] == 3'b111），将该字节累加到 `sum` 中
- **校验判断**：当接收满 40 位数据时，比较累加和 `sum` 与接收到的校验和 `sum_check`
- **校验标志**：如果两者相等，`out_check_flag` 输出高电平，表示数据接收正确

```verilog
always @ (posedge clk or negedge rst_n) begin 
    if(!rst_n)
        sum <= 8'b0;
    else if(head_check)
        sum <= 8'b0;
    else if(bit_cnt[2:0] == 3'b111 && bit_cnt[5] != 1'b1)
        sum <= sum + {data[6:0], data_in};
end

assign out_check_flag = ((bit_cnt==6'd40) && (sum_check == sum));
```

## ModelSim(Verilog TB代码仿真)

本工程包含完整的仿真测试平台 `seq_rd_tb.v`，用于验证串行数据接收和校验功能。

### 仿真环境配置

- **时间单位**：`timescale 10ns/100ps`（时间刻度 10ns，时间精度 100ps）
- **时钟频率**：100MHz（周期 10ns）
- **仿真时长**：约 480 个时钟周期（10 次完整的数据帧传输）

### 测试激励

1. **时钟生成**：产生周期为 10ns 的连续时钟信号（100MHz）
2. **复位序列**：

   - 初始时刻 rst_n=0，复位系统
   - 200ns 后释放复位（rst_n=1）
3. **测试数据帧**（重复 10 次）：

每个数据帧包含 48 位数据（8 位帧头 + 40 位数据）：

#### 帧头（8位）："11101000"

- 位 1-3：`111`（连续三个 1）
- 位 4：`0`
- 位 5：`1`
- 位 6-8：`000`（连续三个 0）

#### 数据部分（40位）：

- **out_data0**（8位）：`11110000`（0xF0）
- **out_data1**（8位）：`00001111`（0x0F）
- **out_data2**（8位）：`11111111`（0xFF）
- **out_data3**（8位）：`10101010`（0xAA）
- **sum_check**（8位）：`10101000`（0xA8，等于 0xF0 + 0x0F + 0xFF + 0xAA = 0x2A8，取低 8 位为 0xA8）

### 观察信号

在 ModelSim 中应观察以下关键信号：

1. **head_check**：帧头检测信号，检测到 "11101000" 时置高
2. **bit_cnt**：数据位计数器，从 1 计数到 40
3. **data**：41 位移位寄存器，存储接收的串行数据
4. **out_data0~out_data3**：解析出的 4 个数据字节
5. **sum**：累加和寄存器，实时累加接收到的数据字节
6. **out_check_flag**：校验成功标志，接收完 40 位数据且校验和正确时置高

### 预期结果

对于每个数据帧：

1. **帧头检测阶段**：

   - 输入 8 位帧头序列 "11101000"
   - 检测到帧头后，`head_check` 置高 1 个时钟周期
2. **数据接收阶段**：

   - `bit_cnt` 从 1 开始计数，逐位接收数据
   - 数据通过移位寄存器 `data` 右移存储
   - 每 8 位接收完成后，`sum` 累加该字节
3. **校验验证阶段**：

   - 当 `bit_cnt` 达到 40 时，完成数据接收
   - 系统比较 `sum`（累加和）与 `sum_check`（接收的校验和）
   - 如果相等，`out_check_flag` 置高，表示数据接收正确
   - 解析出的 4 个数据字节显示在 `out_data0~out_data3` 上
4. **周期性验证**：

   - 测试激励重复 10 次，验证系统的连续工作能力
   - 每次数据帧传输后，系统自动复位 `bit_cnt`，准备接收下一帧数据

## FPGA板子硬件实验

本工程不涉及。
