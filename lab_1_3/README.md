# lab_1_3 - BCD计数器Testbench仿真与硬件验证

## 工程概述

本实验设计了一个功能完整的 4 位十进制计数器（0-9），支持异步复位、使能控制和并行数据加载功能。设计包含 50MHz 到 1Hz 的时钟分频电路，适合在 FPGA 开发板上直观观察计数过程。通过完整的测试平台验证了设计的正确性。

## Verilog程序设计

### 模块功能

`CNT10` 模块实现了一个可控的十进制计数器，具有以下功能：

- **循环计数**：0-9 循环计数，计数到 9 后自动回到 0
- **异步复位**：低电平异步复位功能，优先级最高
- **使能控制**：通过 EN 信号控制计数器工作状态
- **并行加载**：支持在使能状态下通过 LOAD 信号加载预置数据
- **进位输出**：当计数值为 9 时产生进位信号

### 功能实现机制

计数器的核心功能包含两部分：

#### 1. 时钟分频电路

设计中包含时钟分频模块，将 50MHz 的系统时钟分频为 1Hz，使计数过程可以直观观察：

- **分频系数**：`DIV_LEN = 50,000,000`（50MHz → 1Hz）
- **分频计数器**：26位计数器 `div_cnt`
- **输出时钟**：`clk` 信号，周期为 1 秒

#### 2. 计数器逻辑

计数器的工作遵循以下优先级逻辑：

1. **复位最高优先级**：`reset_n=0` 时，计数器异步清零（`DOUT=0`），分频电路同时复位
2. **使能控制**：`en=1` 时，计数器才能工作
3. **数据加载**：`en=1` 且 `load_n=0` 时，加载 `DATA` 到计数器
4. **正常计数**：`en=1` 且 `load_n=1` 时，计数器正常递增（0→9→0）
5. **进位输出**：`DOUT=9` 时，`COUT=1`

### 端口说明

| 端口      | 方向   | 位宽 | 说明                                           |
| --------- | ------ | ---- | ---------------------------------------------- |
| CLK_50    | input  | 1    | 50MHz 系统时钟                                 |
| KEY[2]    | input  | 1    | 使能信号 en（高电平有效，不按键=高=使能）      |
| KEY[1]    | input  | 1    | 加载信号 load_n（低电平有效，按下键=低=加载）  |
| KEY[0]    | input  | 1    | 复位信号 reset_n（低电平有效，按下键=低=复位） |
| SW[3:0]   | input  | 4    | 并行输入数据（0-9）                            |
| DOUT[3:0] | output | 4    | 计数输出（0-9）                                |
| COUT      | output | 1    | 进位输出（计数到 9 时为高）                    |

**注意**：

- 代码中：`assign {en, load_n, reset_n} = KEY[2:0]`
- **KEY[2] = en**：不按键时为高电平（1），计数器使能；按下键为低电平（0），计数器禁用
- **KEY[1] = load_n**：不按键时为高电平（1），正常计数；按下键为低电平（0），加载数据
- **KEY[0] = reset_n**：不按键时为高电平（1），正常工作；按下键为低电平（0），复位清零

## ModelSim(Verilog TB代码仿真)

### 测试台说明

测试台 `CNT10_TB.v` 已修改为与主模块端口匹配：

- **使用端口**：`CLK_50`, `KEY[2:0]`, `SW[3:0]`
- **使用 defparam**：通过 `defparam U_CNT10.DIV_LEN = 2` 将分频系数从 50,000,000 改为 2，极大加快仿真速度
- **内部信号访问**：使用层次化路径访问 `clk` 和 `div_cnt` 用于波形观察
- **监控输出**：添加了 `$display` 语句实时显示 DOUT、COUT 和 clk 的变化

### 仿真加速说明

**仿真参数**：

- 测试台使用 `defparam` 将 `DIV_LEN` 修改为 **2**（原值 50,000,000）
- CLK_50 周期：2ns（时钟周期 `#1`，即每 1ns 跳变）
- clk_internal 周期：4ns（DIV_LEN=2，每 2 个 CLK_50 周期跳变一次）
- 计数器更新：每 4ns 变化一次（clk 上升沿）
- 完整 0-9 循环：10 × 4ns = 40ns

**加速效果**：

- 硬件实现：DIV_LEN = 50,000,000，计数器每秒变化一次
- 仿真环境：DIV_LEN = 2，计数器每 4ns 变化一次

测试平台的测试序列：

| KEY[2:0] 状态变化 | SW 值 | 操作说明                               | 预期结果                                |
| ----------------- | ----- | -------------------------------------- | --------------------------------------- |
| 3'b000            | 0000  | 初始化：reset_n(KEY[0])=0 复位         | DOUT=0，clk 和 div_cnt 复位             |
| 3'b001 (en=0)     | 0000  | reset_n=1 解除复位，但 en=0 禁用计数器 | DOUT 保持 0，clk 开始工作但不计数       |
| 3'b101 (en=1)     | 0011  | en=1 使能，load_n=1，设置 SW=3         | clk 跳变时从 0 开始计数：0→1→2→3...  |
| 3'b101，KEY[1]=0  | 0011  | load_n(KEY[1])=0，加载数据             | 在下个 clk 上升沿加载 DOUT=3            |
| 3'b111            | 0011  | load_n=1，恢复正常计数                 | 从 3 继续计数：3→4→5→...→9→0→1... |
| -                 | -     | 仿真结束 $stop                         | 观察到多个完整的 0-9 计数循环           |

**关键理解**：

- 计数器由**分频后的 `clk` 驱动**，不是 `CLK_50`
- `DIV_LEN = 2`：`clk` 每 2 个 `CLK_50` 周期（4ns）跳变一次
- 计数器在 `clk` 的**上升沿**变化，即每 4ns 变化一次
- 完整的 0-9 循环需要 10 × 4ns = 40ns
- 在 2000ns 内可以观察到约 50 个完整循环

**注意**：由于使用了 `defparam DIV_LEN=2`，计数器每 4ns 变化一次（硬件实际为 1Hz = 1s 变化一次）。

## FPGA板子硬件实验

可生成 `.sof` 配置文件，可下载到 FPGA 开发板进行硬件验证。

### 引脚绑定

#### 输入信号

| 信号   | FPGA引脚 | 硬件元件 | 按键状态    | 逻辑说明                             |
| ------ | -------- | -------- | ----------- | ------------------------------------ |
| CLK_50 | （板载） | 板载晶振 | -           | 50MHz 系统时钟                       |
| KEY[2] | E1       | KEY3     | 不按=高电平 | en 使能信号：不按=1=使能，按下=0     |
| KEY[1] | F3       | KEY2     | 按下=低电平 | load_n 加载：不按=1，按下=0=加载数据 |
| KEY[0] | M1       | KEY1     | 按下=低电平 | reset_n 复位：不按=1，按下=0=复位    |
| SW[3]  | M2       | SW4      | 拨上=高电平 | 数据位3                              |
| SW[2]  | M15      | SW3      | 拨上=高电平 | 数据位2                              |
| SW[1]  | M16      | SW2      | 拨上=高电平 | 数据位1                              |
| SW[0]  | E16      | SW1      | 拨上=高电平 | 数据位0                              |

#### 输出信号

| 信号    | FPGA引脚 | 硬件元件 | 说明                         |
| ------- | -------- | -------- | ---------------------------- |
| DOUT[3] | T10      | LED1     | 计数输出位3                  |
| DOUT[2] | R9       | LED2     | 计数输出位2                  |
| DOUT[1] | T9       | LED3     | 计数输出位1                  |
| DOUT[0] | K8       | LED4     | 计数输出位0                  |
| COUT    | K10      | LED6红   | 进位输出（COUT=1 时 LED 暗） |

**LED 显示说明**：

- LED 为低电平点亮
- 当 DOUT = 9（二进制 1001）时，LED1 和 LED4 亮，LED2 和 LED3 灭
- 当 COUT = 1 时，LED6 亮（计数到 9）

### 硬件测试步骤

#### 1. 初始设置

- 将 `output_files/CNT10.sof` 下载到 FPGA 开发板
- 由于包含 1Hz 时钟分频，计数器每秒变化一次，可直观观察
- **确保 KEY3 不按下**（en=1，使能状态），否则计数器不工作

#### 2. 复位测试

- **按下 KEY1**（reset_n=0），所有 LED 熄灭（DOUT=0）
- **释放 KEY1**（reset_n=1），计数器从 0 开始准备计数
- 观察：复位后 LED1-LED4 全部熄灭

#### 3. 使能测试

- **不按 KEY3**：计数器工作（en=1，使能）
- **按下 KEY3**：计数器停止（en=0，禁用），LED 保持当前状态
- **释放 KEY3**：计数器继续工作
- 观察：按下 KEY3 时，LED 不再变化；释放后继续计数

#### 4. 数据加载测试

1. 通过 SW1-SW4 设置加载值（例如：拨 SW1 和 SW3 为上 = 0101 = 5）
2. **确保 KEY3 不按下**（en=1，使能状态）
3. **按下 KEY2**（load_n=0），将开关值加载到计数器
4. **释放 KEY2**（load_n=1），计数器从加载值开始计数
5. 观察：LED 立即显示设置的值，然后继续计数 5→6→7→8→9→0→1...

#### 5. 正常计数观察

- **确保所有按键都不按下**：KEY3不按（en=1）、KEY2不按（load_n=1）、KEY1不按（reset_n=1）
- 观察 LED1-LED4 以二进制形式显示 0→1→2→...→9→0 的循环计数
- 每次计数变化间隔约 1 秒
- 计数值对应关系：
  - 0 = 0000（全灭）
  - 1 = 0001（LED4 亮）
  - 5 = 0101（LED4 和 LED2 亮）
  - 9 = 1001（LED4 和 LED1 亮)

#### 6. 进位信号观察

- 当计数到 9（LED 显示：LED1 和 LED4 亮，LED2 和 LED3 灭）时
- **LED6（红色）变暗**（COUT=1）
- 下一秒，计数器返回 0，LED6 变亮（COUT=0）

# 程序勘误

1.原1006A的工程，最后的`COUT=(Q1==9)`误写作`cout=(Q1==9)`这会直接导致Modelsim仿真时，COUT信号一直会Hiz(高阻态)，绑定的LED6也一直没有响应；已经修正。

2.原1006A工程，TB程序有问题，Modelsim运行直接报错，是 CNT10_TB.v的输入输出没有用CNT10.v的；已经修正。

ChrisChan
2025/10/25