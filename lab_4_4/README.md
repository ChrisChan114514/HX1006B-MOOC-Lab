# lab_4_4 - 带校验的串行数据接收器

## 项目概述

本实验设计了一个带校验功能的串行数据接收系统，用于接收包含帧头、数据和校验和的完整数据帧。系统能够自动识别帧头序列（"11101000"），接收 40 位数据（包括 4 个 8 位数据和 1 个 8 位校验和），并自动进行校验和验证，确保数据传输的正确性。

## 系统架构

本工程包含三个主要模块：

**seq_detect**：序列检测模块，用于识别数据帧的帧头序列"11101000"
**seq_generator**：串行数据生成模块，用于测试时循环生成包含帧头、数据和校验和的完整数据帧
**seq_rd**：串行数据接收模块（顶层模块），用于接收串行数据并进行校验

## Verilog程序设计

### 序列检测模块（seq_detect.v）

#### 模块功能

`seq_detect` 模块实现了一个状态机序列检测器，用于识别特定的帧头序列"11101000"，具有以下特性：

- **序列识别**：检测特定的 8 位序列 "11101000" 作为数据帧的起始标志
- **状态机设计**：使用 Moore 型有限状态机，包含 9 个状态（s0~s8）
- **重叠检测**：支持重叠序列检测，提高检测效率
- **异步复位**：低电平异步复位功能，优先级最高
- **实时检测**：逐位检测输入数据流，检测到完整序列时输出高电平

#### 端口说明

| 端口    | 方向   | 位宽 | 说明                         |
| ------- | ------ | ---- | ---------------------------- |
| clk     | input  | 1    | 系统时钟                     |
| rst_n   | input  | 1    | 异步复位信号（低电平有效）   |
| data_in | input  | 1    | 串行数据输入                 |
| sout    | output | 1    | 序列检测输出（检测成功为高） |

#### 状态转移设计

状态机共有 9 个状态，分别对应检测序列"11101000"的不同阶段：

- **s0**：初始状态，等待第一个'1'
- **s1**：检测到第一个'1'，等待第二个'1'
- **s2**：检测到两个'1'，等待第三个'1'
- **s3**：检测到三个'1'，等待'0'
- **s4**：检测到"1110"，等待'1'
- **s5**：检测到"11101"，等待'0'
- **s6**：检测到"111010"，等待第二个'0'
- **s7**：检测到"1110100"，等待第三个'0'
- **s8**：检测到完整序列"11101000"，输出检测成功信号

状态转移支持重叠检测，当检测失败时会根据已接收的数据跳转到合适的中间状态，避免丢失可能的序列起始位。

### 串行数据接收模块（seq_rd.v）

#### 模块功能

`seq_rd` 模块是顶层接收模块，实现了完整的串行数据接收和校验功能，具有以下特性：

- **帧头识别**：调用 `seq_detect` 模块自动识别帧头序列
- **数据接收**：接收 40 位串行数据（4 个 8 位数据 + 1 个 8 位校验和）
- **串并转换**：将串行输入数据转换为并行数据输出
- **实时校验**：边接收边计算前 4 个字节的校验和
- **校验验证**：接收完成后自动比对计算的校验和与接收的校验和
- **异步复位**：低电平异步复位功能，优先级最高

#### 端口说明

| 端口           | 方向   | 位宽 | 说明                                   |
| -------------- | ------ | ---- | -------------------------------------- |
| clk            | input  | 1    | 系统时钟                               |
| rst_n          | input  | 1    | 异步复位信号（低电平有效）             |
| data_in        | input  | 1    | 串行数据输入                           |
| out_data0      | output | 8    | 第一个数据字节输出                     |
| out_data1      | output | 8    | 第二个数据字节输出                     |
| out_data2      | output | 8    | 第三个数据字节输出                     |
| out_data3      | output | 8    | 第四个数据字节输出                     |
| out_check_flag | output | 1    | 校验成功标志（高电平表示校验和匹配）   |

#### 功能实现机制

##### 1. 帧头检测

通过实例化 `seq_detect` 模块实现帧头"11101000"的自动识别：

```verilog
seq_detect u_seq_detect(
    .clk        (clk),
    .rst_n      (rst_n),
    .data_in    (data_in),
    .sout       (head_check)
);
```

当 `head_check` 信号为高时，表示检测到帧头，系统开始接收后续的 40 位数据。

##### 2. 数据接收与串并转换

使用 6 位计数器 `bit_cnt` 和 41 位移位寄存器 `data` 实现数据接收：

- **计数范围**：1~40（接收 40 位数据）
- **移位接收**：每个时钟周期将 `data_in` 移入寄存器低位，高位数据依次上移
- **起始控制**：检测到帧头后开始计数和接收
- **停止条件**：接收满 40 位后停止

```verilog
always @ (posedge clk or negedge rst_n)
begin 
    if(!rst_n) begin 
        bit_cnt <= 6'b0;
        data <= 40'b0;
    end
    else if(head_check) begin
        bit_cnt <= 6'd1;
        data[0] <= data_in;
    end
    else if(bit_cnt < 6'd40) begin
        bit_cnt <= bit_cnt + 1'b1;
        data[0] <= data_in;
        data[40:1] <= data[39:0];
    end
    else begin
        bit_cnt <= 6'b0;
    end
end
```

##### 3. 实时校验和计算

在接收数据的同时，实时累加前 4 个字节（DATA0~DATA3）的校验和：

- **累加时机**：每接收完一个字节（`bit_cnt[2:0]==3'b111`）时累加
- **累加范围**：只累加前 4 个字节（`bit_cnt[5]!=1'b1`），不包括校验和本身
- **复位控制**：检测到新帧头时清零校验和

```verilog
always @ (posedge clk or negedge rst_n)
begin 
    if(!rst_n)
        sum <= 8'b0;
    else if(head_check)
        sum <= 8'b0;
    else if(bit_cnt[2:0] == 3'b111 && bit_cnt[5] != 1'b1)
        sum <= sum + {data[6:0], data_in};
end
```

##### 4. 校验验证

接收完成后，自动比对计算的校验和与接收的校验和：

```verilog
assign {out_data0, out_data1, out_data2, out_data3, sum_check} = data[39:0];
assign out_check_flag = ((bit_cnt==6'd40) && (sum_check == sum));
```

- **数据分配**：将 40 位数据分解为 4 个数据字节和 1 个校验和字节
- **校验判断**：当接收完 40 位且计算的校验和与接收的校验和相等时，`out_check_flag` 输出高电平

#### 数据帧结构

接收的数据帧包含 48 位，结构如下：

| 位范围 | 内容       | 说明                     |
| ------ | ---------- | ------------------------ |
| 0-7    | 帧头       | "11101000"（由检测器识别）|
| 8-15   | DATA0      | 第一个数据字节           |
| 16-23  | DATA1      | 第二个数据字节           |
| 24-31  | DATA2      | 第三个数据字节           |
| 32-39  | DATA3      | 第四个数据字节           |
| 40-47  | 校验和     | DATA0+DATA1+DATA2+DATA3的低8位 |

### 串行数据生成模块（seq_generator.v）

#### 模块功能

`seq_generator` 模块实现了一个循环的串行数据生成器，用于测试串行数据接收系统，具有以下特性：

- **帧头生成**：生成特定的 8 位序列 "11101000" 作为数据帧的起始标志
- **数据输出**：输出 4 个 8 位数据字节（DATA0~DATA3）
- **校验和生成**：输出 8 位校验和（4 个数据字节的和）
- **循环传输**：完成一帧数据（48 位）后自动重新开始
- **异步复位**：低电平异步复位功能，优先级最高
- **串行输出**：按位输出数据，每个时钟周期输出 1 位

#### 端口说明

| 端口  | 方向   | 位宽 | 说明                       |
| ----- | ------ | ---- | -------------------------- |
| clk   | input  | 1    | 系统时钟                   |
| rst_n | input  | 1    | 异步复位信号（低电平有效） |
| data  | output | 1    | 串行数据输出               |

#### 参数定义

模块定义了以下常量参数，用于指定输出的数据内容：

```verilog
parameter HEAD  = 8'b11101000;  // 帧头序列
parameter DATA0 = 8'b11110000;  // 第一个数据字节 (0xF0)
parameter DATA1 = 8'b00001111;  // 第二个数据字节 (0x0F)
parameter DATA2 = 8'b11111111;  // 第三个数据字节 (0xFF)
parameter DATA3 = 8'b10101010;  // 第四个数据字节 (0xAA)
parameter SUM   = 8'b10101000;  // 校验和 (0xA8 = 0xF0+0x0F+0xFF+0xAA的低8位)
```

#### 功能实现机制

##### 1. 位计数器

使用 6 位计数器 `bit_cnt` 记录当前输出的位位置（0~47，共 48 位）：

- **计数范围**：0~47（6 个字节 × 8 位/字节）
- **循环计数**：计数到 47 后自动归零，实现循环发送
- **复位行为**：异步复位时清零

```verilog
always @ (posedge clk or negedge rst_n)
begin 
    if(!rst_n)
        bit_cnt <= 1'b0;
    else if(bit_cnt < 6'd47)
        bit_cnt <= bit_cnt + 1'b1;
    else
        bit_cnt <= 1'b0;
end
```

##### 2. 数据输出逻辑

根据位计数器的高 3 位 `bit_cnt[5:3]` 选择当前输出的字节，根据低 3 位 `bit_cnt[2:0]` 选择字节内的具体位：

- **字节选择**：通过 `case` 语句根据 `bit_cnt[5:3]` 确定输出哪个字节
- **位选择**：使用 `7-bit_cnt[2:0]` 实现从高位到低位的顺序输出
- **输出顺序**：先输出帧头，依次输出 DATA0~DATA3，最后输出校验和

```verilog
always @ (posedge clk or negedge rst_n)
begin 
    if(!rst_n)
        data <= 1'b0;
    else
        case(bit_cnt[5:3])
            3'b000 : data <= HEAD[3'd7-bit_cnt[2:0]];   // 位 0-7: 帧头
            3'b001 : data <= DATA0[3'd7-bit_cnt[2:0]];  // 位 8-15: DATA0
            3'b010 : data <= DATA1[3'd7-bit_cnt[2:0]];  // 位 16-23: DATA1
            3'b011 : data <= DATA2[3'd7-bit_cnt[2:0]];  // 位 24-31: DATA2
            3'b100 : data <= DATA3[3'd7-bit_cnt[2:0]];  // 位 32-39: DATA3
            3'b101 : data <= SUM[3'd7-bit_cnt[2:0]];    // 位 40-47: 校验和
        endcase
end
```

#### 数据帧结构

完整的数据帧包含 48 位，结构如下：

| 位范围 | 字节名称 | 内容     | 十六进制值 |
| ------ | -------- | -------- | ---------- |
| 0-7    | HEAD     | 11101000 | 0xE8       |
| 8-15   | DATA0    | 11110000 | 0xF0       |
| 16-23  | DATA1    | 00001111 | 0x0F       |
| 24-31  | DATA2    | 11111111 | 0xFF       |
| 32-39  | DATA3    | 10101010 | 0xAA       |
| 40-47  | SUM      | 10101000 | 0xA8       |

**校验和计算**：SUM = (DATA0 + DATA1 + DATA2 + DATA3) & 0xFF = (0xF0 + 0x0F + 0xFF + 0xAA) & 0xFF = 0x2A8 & 0xFF = 0xA8

## ModelSim(Verilog TB代码仿真)

本工程使用 ModelSim 进行功能仿真，验证串行数据接收系统的正确性。测试平台包含数据发生器和接收器两部分，形成完整的发送-接收闭环测试。

### 测试平台架构

测试平台 `seq_tb` 实例化了两个关键模块：

1. **seq_generator**：数据发生器，循环生成包含帧头、数据和校验和的完整数据帧
2. **seq_rd**：数据接收器（被测模块），接收串行数据并进行校验

两个模块通过 `data_in` 信号连接，形成发送-接收测试环境。

### 仿真环境配置

- **时间单位**：`timescale 10ns/100ps
- **时钟周期**：10个时间单位（100ns）
- **仿真时长**：2000个时间单位，足够观察 4 个完整数据帧的收发过程

### 测试激励

测试平台提供以下激励：

1. **时钟生成**：产生周期为 10 个时间单位的连续时钟信号
2. **复位序列**：
   - 初始时刻 `rst_n=0`，复位系统
   - 延时 15 个时间单位后释放复位（`rst_n=1`）
3. **自动测试**：复位释放后，发生器自动循环发送数据，接收器自动接收并校验

### 观察信号

在 ModelSim 中应观察以下关键信号：

#### 发送端信号
1. **u_seq_generator/clk**：系统时钟信号
2. **u_seq_generator/rst_n**：复位信号
3. **u_seq_generator/bit_cnt**：发送位计数器（0~47）
4. **data_in**：串行数据输出，连接到接收器输入

#### 接收端信号
1. **u_seq_rd/head_check**：帧头检测信号（检测到帧头时为高）
2. **u_seq_rd/bit_cnt**：接收位计数器（1~40）
3. **u_seq_rd/data**：41位数据移位寄存器
4. **u_seq_rd/sum**：实时累加的校验和
5. **out_data0**：接收到的第一个数据字节（应为 0xF0）
6. **out_data1**：接收到的第二个数据字节（应为 0x0F）
7. **out_data2**：接收到的第三个数据字节（应为 0xFF）
8. **out_data3**：接收到的第四个数据字节（应为 0xAA）
9. **out_check_flag**：校验成功标志（高电平表示校验通过）

### 预期结果

在正常工作状态下，应观察到以下行为：

#### 1. 复位阶段

- `rst_n=0` 时，发送器和接收器的 `bit_cnt` 均清零
- 发送器的 `data` 输出为 0，接收器的输出端口清零
- 释放复位后，系统开始正常工作

#### 2. 数据发送阶段

发送器循环输出 48 位数据帧：

- **位 0-7**（bit_cnt=0~7）：输出帧头 "11101000"
- **位 8-15**（bit_cnt=8~15）：输出 DATA0 "11110000"
- **位 16-23**（bit_cnt=16~23）：输出 DATA1 "00001111"
- **位 24-31**（bit_cnt=24~31）：输出 DATA2 "11111111"
- **位 32-39**（bit_cnt=32~39）：输出 DATA3 "10101010"
- **位 40-47**（bit_cnt=40~47）：输出 SUM "10101000"

#### 3. 帧头检测阶段

- 当发送器输出完整的帧头序列"11101000"时
- 接收器的 `head_check` 信号应在第 8 个时钟周期拉高一个周期
- 此时接收器的 `bit_cnt` 从 0 变为 1，开始接收数据
- 接收器的 `sum` 校验和计数器清零

#### 4. 数据接收阶段

- 接收器的 `bit_cnt` 从 1 累加到 40
- 数据通过移位寄存器 `data` 逐位接收
- 每接收完 8 位（一个字节），`sum` 累加该字节值
- 只累加前 4 个字节（DATA0~DATA3），不累加第 5 个字节（校验和）

#### 5. 校验验证阶段

- 当 `bit_cnt` 达到 40 时，接收完成
- `out_data0` = 0xF0（11110000）
- `out_data1` = 0x0F（00001111）
- `out_data2` = 0xFF（11111111）
- `out_data3` = 0xAA（10101010）
- 计算的 `sum` = 0xA8
- 接收的校验和 `sum_check` = 0xA8
- 由于两者相等，`out_check_flag` 拉高，表示校验通过

#### 6. 循环工作

- 发送器完成 48 位输出后，`bit_cnt` 自动归零
- 系统重新开始输出下一帧数据
- 接收器在检测到新的帧头后，重复接收过程
- 每帧数据内容完全相同，`out_check_flag` 应周期性地出现高电平

#### 7. 关键验证点

- **帧头检测准确性**：验证 `head_check` 信号是否在正确的时刻拉高
- **数据完整性**：验证接收到的 4 个数据字节是否与发送的一致
- **校验和正确性**：验证 `sum` = (0xF0 + 0x0F + 0xFF + 0xAA) & 0xFF = 0x2A8 & 0xFF = 0xA8
- **校验标志时序**：验证 `out_check_flag` 是否在接收完 40 位时正确拉高
- **循环连续性**：验证系统能否连续接收多帧数据而不出错

## FPGA板子硬件实验

本工程不涉及。

2025/10/29

ChrisChan
